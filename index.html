<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Beautifull üíï CSS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://use.typekit.net/trt3ngp.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Parisienne&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      overflow: hidden;
      background: linear-gradient(180deg, #1a0d1a 0%, #2b0f2b 100%); /* Dreamy gradient */
      color: #ffccff;
      -webkit-font-smoothing: antialiased;
    }

    .webgl {
      position: fixed;
      width: 100vw;
      height: 100vh;
      top: 0;
      left: 0;
      outline: none;
    }

    body::before {
      content: '';
      position: absolute;
      inset: 1rem;
      z-index: 100;
      pointer-events: none;
    }

    #play-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 103;
      width: 100px;
      height: 100px;
      background-color: rgba(255, 102, 204, 0.5);
      border: 2px solid #ffccff;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
    }
    #play-button:hover {
      transform: translate(-50%, -50%) scale(1.1);
      background-color: rgba(255, 102, 204, 0.7);
    }
    #play-button svg {
      width: 50px;
      height: 50px;
      fill: #ffccff;
      margin-left: 10px; /* Centrado visual del icono de play */
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }
  </style>
  <style>
    /* Estilos para el texto de introducci√≥n y la tarjeta de mensaje */
    .intro-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 101;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      cursor: pointer;
      opacity: 0;
      animation: fadeIn 2s ease-in forwards 1s;
    }

    .h1text {
      font-family: 'Parisienne', cursive;
      font-weight: 400;
      font-size: max(4rem, 6vh);
      text-shadow: 0 0 10px rgba(255, 153, 204, 0.7);
      margin-bottom: 1.5rem;
    }

    .dates-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: max(1.5rem, 2.5vh);
      font-family: 'Parisienne', cursive;
    }

    .intro-container.clicked {
      animation: moveUpAndFade 1.5s ease-in-out forwards;
    }

    @keyframes moveUpAndFade {
      to {
        transform: translate(-50%, -150%);
        opacity: 0;
      }
    }

    .message-card {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translate(-50%, 120%); /* Oculto abajo */
      z-index: 102;
      background-color: rgba(43, 15, 43, 0.75);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 204, 255, 0.3);
      border-radius: 15px;
      padding: 2rem 3rem;
      width: 90%;
      max-width: 500px;
      text-align: center;
      font-family: 'Parisienne', cursive;
      font-size: max(2rem, 3.5vh);
      transition: transform 1.5s cubic-bezier(0.25, 1, 0.5, 1);
    }

    .message-card.visible {
      transform: translate(-50%, -50%); /* Sube al centro */
    }
  </style>
</head>

<body>
  <canvas class="webgl"></canvas>
  <div class="intro-container">
    <h1 class="h1text">Para Ti Hermosa ‚ô•Ô∏è</h1>
    <div class="dates-container">
      <!-- <p>25 / 07 / 2024</p> -->
      <p>‚ÄúA veces uno conoce personas que simplemente hacen bien‚Ä¶ <br>sin hacer mucho. T√∫ eres una de esas.‚Äù</p>
    </div>
  </div>

  <div class="message-card">
    <p>Espero te vaya bien ma√±ana</p>
  </div>

  <button id="play-button" aria-label="Reproducir m√∫sica">
    <svg viewBox="0 0 448 512">
      <path d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"/>
    </svg>
  </button>

  <!-- Los shaders (el c√≥digo GLSL) se han eliminado. La nueva l√≥gica estar√° en el script de abajo -->

  <script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.135.0";
    import { gsap } from "https://cdn.skypack.dev/gsap@3.8.0";
    import { GLTFLoader } from "https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/GLTFLoader";

    // Helper function for modulo that always returns a positive result
    const mod = (n, m) => ((n % m) + m) % m;

    class World {
      // Aqu√≠ ir√° el resto del c√≥digo JavaScript
            constructor({
        canvas,
        width,
        height,
        cameraPosition,
        fieldOfView = 75,
        nearPlane = 0.1,
        farPlane = 100
      }) {
        this.parameters = {
          a: 2,
          c: 4.5
        };

        this.textureLoader = new THREE.TextureLoader();
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a0d1a);
        this.clock = new THREE.Clock();
        this.data = 0;
        this.time = { current: 0, t0: 0, t1: 0, t: 0, frequency: 0.0005, delta: 0, elapsed: 0 };
        this.angle = { x: 0, z: 0 };
        this.width = width || window.innerWidth;
        this.isRunning = false;
        this.height = height || window.innerHeight;
        this.aspectRatio = this.width / this.height;
        this.fieldOfView = fieldOfView;
        
        this.camera = new THREE.PerspectiveCamera(
          fieldOfView,
          this.aspectRatio,
          nearPlane,
          farPlane
        );
        this.camera.position.set(
          cameraPosition.x,
          cameraPosition.y,
          cameraPosition.z
        );
        this.scene.add(this.camera);
        
        this.renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true
        });
        this.pixelRatio = Math.min(window.devicePixelRatio, 2);
        this.renderer.setPixelRatio(this.pixelRatio);
        this.renderer.setSize(this.width, this.height);
        
        this.init();
      }

      // Aqu√≠ ir√° el resto del c√≥digo JavaScript
      async init() {
        await this.addModelsAndParticles();
        this.setupIntroAnimation();
        this.setupPlayButton();
        this.listenToResize();
        this.listenToMouseMove();
        this.loop();
      }

      render() {
        this.renderer.render(this.scene, this.camera);
      }

      loop() {
        this.time.elapsed = this.clock.getElapsedTime();
        this.time.delta = this.time.elapsed - this.time.current;
        this.time.current = this.time.elapsed;

        if (this.analyser && this.isRunning) {
          this.time.t = this.time.elapsed - this.time.t0 + this.time.t1;
          this.data = this.analyser.getAverageFrequency();
          this.data *= this.data / 2000;
          this.angle.x += this.time.delta * 0.63;
          this.angle.z += this.time.delta * 0.39;
          const justFinished = this.isRunning && !this.sound.isPlaying;
          if (justFinished) {
            this.time.t1 = this.time.t;
            this.isRunning = false;
            const tl = gsap.timeline();
            this.angle.x = 0;
            this.angle.z = 0;
            tl.to(this.camera.position, {
              x: 0,
              z: 4.5,
              duration: 4,
              ease: "expo.in"
            });
          } else {
            this.camera.position.x = Math.sin(this.angle.x) * this.parameters.a;
            this.camera.position.z = Math.min(
              Math.max(Math.cos(this.angle.z) * this.parameters.c, 1.75),
              6.5
            );
          }
        }
        
        this.camera.lookAt(this.scene.position);
        
        // La rotaci√≥n del coraz√≥n central se ha eliminado ya que el objeto no existe.
        this.updateHeartParticles();
        this.updateSnowParticles();
        
        this.render();
        requestAnimationFrame(this.loop.bind(this));
      }

      // Aqu√≠ ir√° el resto del c√≥digo JavaScript
            async addModelsAndParticles() {
        const gltfLoader = new GLTFLoader();
        const heartModel = await gltfLoader.loadAsync("https://assets.codepen.io/74321/heart.glb");
        
        const heartGeometry = heartModel.scene.children[0].geometry;
        
        // Centramos y escalamos la geometr√≠a para poder instanciarla f√°cilmente
        heartGeometry.center();
        heartGeometry.scale(15, 15, 15); // Ajusta la escala para el tama√±o de part√≠cula que necesitamos

        // El coraz√≥n rojo central ha sido eliminado.

        // Ahora creamos las part√≠culas usando la misma geometr√≠a
        this.createHeartParticles(heartGeometry);
        this.createSnowParticles(heartGeometry);
      }

      createHeartParticles(geometry) {
        const count = 3000;
        const material = new THREE.MeshMatcapMaterial({
            matcap: this.textureLoader.load("https://assets.codepen.io/74321/3.png"),
            color: "#ff66cc"
        });

        this.heartInstances = new THREE.InstancedMesh(geometry, material, count);
        this.scene.add(this.heartInstances);

        this.heartParticles = [];
        for (let i = 0; i < count; i++) {
            this.heartParticles.push({
                matrix: new THREE.Matrix4(),
                speed: Math.random() * 0.5 + 0.5,
                random: Math.random(),
                random1: Math.random(),
            });
        }
      }

      createSnowParticles(geometry) {
        const count = 550;
        const material = new THREE.MeshMatcapMaterial({
            matcap: this.textureLoader.load("https://assets.codepen.io/74321/3.png"),
            color: "#ffccff",
            transparent: true,
            opacity: 0.8
        });

        this.snowInstances = new THREE.InstancedMesh(geometry, material, count);
        this.scene.add(this.snowInstances);

        this.snowParticles = [];
        for (let i = 0; i < count; i++) {
            this.snowParticles.push({
                matrix: new THREE.Matrix4(),
                position: new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                ),
                rotation: new THREE.Euler(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                ),
                speed: Math.random() * 0.1 + 0.05,
                random: Math.random(),
            });
        }
      }

      // Aqu√≠ ir√° el resto del c√≥digo JavaScript
            updateHeartParticles() {
        if (!this.heartInstances) return;

        const time = this.time.elapsed * 0.5;
        const musicEffect = 1 + this.data * 0.2;
        const radius = 1.2; // Radio aumentado para hacer la forma del coraz√≥n m√°s grande

        for (let i = 0; i < this.heartParticles.length; i++) {
            const particle = this.heartParticles[i];
            
            const sign = (particle.random > 0.5) ? 1.0 : -1.0;
            let t = mod(-time * particle.speed * 0.05 + 10.0 * particle.speed * particle.speed, Math.PI);
            t *= sign;

            const a = Math.pow(t, 2.0) * Math.pow((t - sign * Math.PI), 2.0);
            
            const x = radius * 16.0 * Math.pow(Math.sin(t), 3.0);
            const y = radius * (13.0 * Math.cos(t) - 5.0 * Math.cos(2.0 * t) - 2.0 * Math.cos(3.0 * t) - Math.cos(4.0 * t));
            const z = 0.15 * (a * (particle.random1 - 0.5)) * Math.sin(Math.abs(10.0 * (Math.sin(0.2 * time + 0.2 * particle.random))) * t);
            const swirlAmplitude = 0.5; // Ajusta la amplitud del torbellino
            const verticalOffset = Math.sin(time * particle.speed * 2) * swirlAmplitude; // Movimiento vertical

            const scale = 0.005 * Math.pow(a, 0.5) * 0.5;

            particle.matrix.makeRotationFromEuler(new THREE.Euler(time * particle.speed, time * particle.speed * 2, time * particle.speed * 3)); // Rotaci√≥n para el torbellino
            particle.matrix.setPosition(x, y, z);
            particle.matrix.scale(new THREE.Vector3(scale, scale, scale));
            
            this.heartInstances.setMatrixAt(i, particle.matrix);
        }
        this.heartInstances.instanceMatrix.needsUpdate = true;
      }

      updateSnowParticles() {
        if (!this.snowInstances) return;

        const time = this.time.elapsed;
        const musicEffect = 1 + this.data * 0.1;

        for (let i = 0; i < this.snowParticles.length; i++) {
            const particle = this.snowParticles[i];

            particle.position.y -= particle.speed * this.time.delta * 20 * musicEffect;
            if (particle.position.y < -5) {
                particle.position.y = 5;
            }

            particle.rotation.x += particle.speed * this.time.delta * 0.5;
            particle.rotation.y += particle.speed * this.time.delta * 0.5;

            const scale = 0.01 + Math.sin(time * particle.speed) * 0.005;

            particle.matrix.makeRotationFromEuler(particle.rotation);
            particle.matrix.setPosition(particle.position);
            particle.matrix.scale(new THREE.Vector3(scale, scale, scale));

            this.snowInstances.setMatrixAt(i, particle.matrix);
        }
        this.snowInstances.instanceMatrix.needsUpdate = true;
      }

      // Aqu√≠ ir√° el resto del c√≥digo JavaScript
            listenToResize() {
        window.addEventListener("resize", () => {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
          this.camera.aspect = this.width / this.height;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(this.width, this.height);
        });
      }

      listenToMouseMove() {
        window.addEventListener("mousemove", e => {
          const x = e.clientX;
          const y = e.clientY;
          gsap.to(this.camera.position, {
            x: gsap.utils.mapRange(0, window.innerWidth, 0.2, -0.2, x),
            y: gsap.utils.mapRange(0, window.innerHeight, 0.2, -0.2, -y)
          });
        });
      }

      setupIntroAnimation() {
        const introContainer = document.querySelector('.intro-container');
        const messageCard = document.querySelector('.message-card');

        if (!introContainer || !messageCard) return;

        introContainer.addEventListener('click', () => {
            const playButton = document.getElementById('play-button');
            if (playButton.style.display !== 'none') return;

            introContainer.classList.add('clicked');

            setTimeout(() => {
                messageCard.classList.add('visible');
            }, 1000);

        }, { once: true });
      }

      setupPlayButton() {
        const playButton = document.getElementById('play-button');
        if (!playButton) return;

        playButton.addEventListener('click', () => {
            gsap.to(playButton, {
                opacity: 0,
                duration: 0.5,
                onComplete: () => playButton.style.display = 'none'
            });

            const listener = new THREE.AudioListener();
            this.camera.add(listener);
            this.sound = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();

            audioLoader.load(
                "./Assets/musica1.mp3",
                (buffer) => {
                    this.sound.setBuffer(buffer);
                    this.sound.setLoop(true);
                    this.sound.setVolume(0.5);
                    this.sound.play();
                    this.analyser = new THREE.AudioAnalyser(this.sound, 32);
                    this.isRunning = true;
                    this.time.t0 = this.time.elapsed;
                },
                () => {},
                (error) => console.error('Error al cargar la m√∫sica:', error)
            );
        }, { once: true });
      }
    }

    const world = new World({
      canvas: document.querySelector("canvas.webgl"),
      cameraPosition: { x: 0, y: 0, z: 4.5 }
    });

  </script>
</body>
</html>
